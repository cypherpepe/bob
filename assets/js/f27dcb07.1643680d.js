"use strict";(self.webpackChunkBOB_docs=self.webpackChunkBOB_docs||[]).push([[8590],{5123:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>d,contentTitle:()=>n,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>c});var r=i(4848),o=i(8453);const s={},n="zkVM Taproot Address Ownership Proofs",a={id:"build/examples/zkvm-taproot/index",title:"zkVM Taproot Address Ownership Proofs",description:"This demo uses zkVM to prove ownership of a Bitcoin taproot address. A user submits a Bitcoin private key to zkVM, which will derive the public key and submit it to BOB Sepolia (Testnet). Because of the zero-knowledge (zk) part of zkVM, no information regarding the private key gets published. The proof is generated by Bonsai and verified on-chain.",source:"@site/docs/build/examples/zkvm-taproot/index.md",sourceDirName:"build/examples/zkvm-taproot",slug:"/build/examples/zkvm-taproot/",permalink:"/docs/build/examples/zkvm-taproot/",draft:!1,unlisted:!1,editUrl:"https://github.com/bob-collective/bob/tree/master/docs/docs/build/examples/zkvm-taproot/index.md",tags:[],version:"current",frontMatter:{},sidebar:"buildSidebar",previous:{title:"Unified EVM and Bitcoin Assets with the MetaMask Bitcoin Snap Extension",permalink:"/docs/build/examples/unified-assets-tracker/"},next:{title:"Account Abstraction",permalink:"/docs/build/tools/account-abstraction"}},d={},c=[{value:"Limitations, Notes and Warnings",id:"limitations-notes-and-warnings",level:2},{value:"Demo",id:"demo",level:2},{value:"Prerequisites",id:"prerequisites",level:3},{value:"Running the Demo",id:"running-the-demo",level:3},{value:"1. Account Creation and Funding",id:"1-account-creation-and-funding",level:4},{value:"2. Deploy the Contracts",id:"2-deploy-the-contracts",level:4},{value:"3. Start the Relayer",id:"3-start-the-relayer",level:4},{value:"4. Start Bitcoin Core",id:"4-start-bitcoin-core",level:4},{value:"5. Create an Ordinals Wallet",id:"5-create-an-ordinals-wallet",level:4},{value:"6. Create a Taproot Address",id:"6-create-a-taproot-address",level:4},{value:"7. Prove Ownership of the Address",id:"7-prove-ownership-of-the-address",level:4},{value:"Diving into the Code",id:"diving-into-the-code",level:2}];function l(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"zkvm-taproot-address-ownership-proofs",children:"zkVM Taproot Address Ownership Proofs"})}),"\n",(0,r.jsxs)(t.p,{children:["This demo uses ",(0,r.jsx)(t.a,{href:"https://dev.risczero.com/zkvm/",children:"zkVM"})," to prove ownership of a Bitcoin taproot address. A user submits a Bitcoin private key to zkVM, which will derive the public key and submit it to BOB Sepolia (Testnet). Because of the zero-knowledge (zk) part of zkVM, no information regarding the private key gets published. The proof is generated by ",(0,r.jsx)(t.a,{href:"https://dev.risczero.com/bonsai/",children:"Bonsai"})," and verified on-chain."]}),"\n",(0,r.jsx)(t.admonition,{title:"Example Code",type:"info",children:(0,r.jsxs)(t.p,{children:["The code of the demo can be found in ",(0,r.jsx)(t.a,{href:"https://github.com/bob-collective/demo-zkvm-taproot-address/",children:"this repository"}),"."]})}),"\n",(0,r.jsx)(t.h2,{id:"limitations-notes-and-warnings",children:"Limitations, Notes and Warnings"}),"\n",(0,r.jsx)(t.p,{children:"This demo is a demonstration of the technical possibilities rather than something to use in production. In production, other approaches are more suitable, such as signing a message with the private key, and having zkVM check that signed message using the public key."}),"\n",(0,r.jsx)(t.admonition,{type:"warning",children:(0,r.jsxs)(t.p,{children:["It is important to note that while zkVM does not leak information about the private key, the private key ",(0,r.jsx)(t.em,{children:"is"})," received by the Bonsai API, which means that you have to trust this service to not steal your keys. As such, it is not recommended to use this demo on production accounts and generate a new throwaway key for trying this demo."]})}),"\n",(0,r.jsxs)(t.p,{children:["Finally, taproot addresses are pretty flexible - the spending condition can be either pubkey-based (like P2PK) or script-based (like P2SH). This demo only works for taproot addresses of the former type. Specifically is written to work only with Bitcoin-core wallets, where wallets and addresses are created using the ",(0,r.jsx)(t.code,{children:"ord"})," tool."]}),"\n",(0,r.jsx)(t.h2,{id:"demo",children:"Demo"}),"\n",(0,r.jsx)(t.h3,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,r.jsx)(t.p,{children:"This demo has the following prerequisites:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"https://bitcoin.org/en/bitcoin-core/",children:"bitcoin-core"})," version 23 or higher. Tests were done with version 25."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"https://github.com/ordinals/ord",children:"ord"})," for address and wallet generation."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"https://github.com/risc0/bonsai-foundry-template",children:"risc0 dependencies"})," for the zkVM program compilation."]}),"\n",(0,r.jsxs)(t.li,{children:["a ",(0,r.jsx)(t.a,{href:"https://dev.risczero.com/bonsai/quickstart",children:"Bonsai API key"}),". The commands below will use ",(0,r.jsx)(t.code,{children:"$API_KEY"})," - substitute this for your key."]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"running-the-demo",children:"Running the Demo"}),"\n",(0,r.jsx)(t.p,{children:"To execute the demo, perform the following steps:"}),"\n",(0,r.jsx)(t.h4,{id:"1-account-creation-and-funding",children:"1. Account Creation and Funding"}),"\n",(0,r.jsxs)(t.p,{children:["Create a new Ethereum account using e.g. MetaMask, and fund the account using the l2 faucet on ",(0,r.jsx)(t.a,{href:"https://app.conduit.xyz/published/view/fluffy-bob-7mjgi9pmtg",children:"this page"}),". The private key of this account will be used in the commands below (substitute the ",(0,r.jsx)(t.code,{children:"DEPLOYER_PRIVATE_KEY"})," variable)."]}),"\n",(0,r.jsx)(t.h4,{id:"2-deploy-the-contracts",children:"2. Deploy the Contracts"}),"\n",(0,r.jsx)(t.p,{children:"Deploy the necessary contracts (the Bonsai relay, verifier, and the TaprootRegister):"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:"forge script script/Deploy.s.sol --rpc-url https://l2-fluffy-bob-7mjgi9pmtg.t.conduit.xyz --broadcast --verify --verifier blockscout --verifier-url 'https://explorerl2-fluffy-bob-7mjgi9pmtg.t.conduit.xyz/api?'\n"})}),"\n",(0,r.jsx)(t.p,{children:"After running the command above, look for output like this:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"== Logs ==\n  Deployed RiscZeroGroth16Verifier to  [...]\n  Deployed BonsaiRelay to  [...]\n  Image ID for taproot-derive is  [...]\n  Deployed TaprootRegister to  [...]\n"})}),"\n",(0,r.jsxs)(t.p,{children:["The commands below will use the ",(0,r.jsx)(t.code,{children:"$BONSAI_RELAY"})," and ",(0,r.jsx)(t.code,{children:"$TAPROOT_REGISTER"})," values - substitute those for the addresses logged above."]}),"\n",(0,r.jsx)(t.h4,{id:"3-start-the-relayer",children:"3. Start the Relayer"}),"\n",(0,r.jsx)(t.p,{children:"Start a relayer client (and leave it running in the background):"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:"BONSAI_API_URL=https://api.bonsai.xyz/ BONSAI_API_KEY=$API_KEY cargo run --bin bonsai-ethereum-relay-cli -- run --relay-address $BONSAI_RELAY --eth-node wss://l2-fluffy-bob-7mjgi9pmtg.t.conduit.xyz --eth-chain-id 901 --private-key $DEPLOYER_PRIVATE_KEY\n"})}),"\n",(0,r.jsx)(t.h4,{id:"4-start-bitcoin-core",children:"4. Start Bitcoin Core"}),"\n",(0,r.jsx)(t.p,{children:"Start a regtest Bitcoin daemon:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:"bitcoind -regtest -server -rpcuser=rpcuser -rpcpassword=rpcpassword -fallbackfee=0.0002 -blockfilterindex -txindex=1 -prune=0 -blockversion=4\n"})}),"\n",(0,r.jsx)(t.h4,{id:"5-create-an-ordinals-wallet",children:"5. Create an Ordinals Wallet"}),"\n",(0,r.jsx)(t.p,{children:"Create an ordinals wallet:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:"ord --regtest --bitcoin-rpc-pass rpcpassword --bitcoin-rpc-user rpcuser wallet create\n"})}),"\n",(0,r.jsx)(t.h4,{id:"6-create-a-taproot-address",children:"6. Create a Taproot Address"}),"\n",(0,r.jsx)(t.p,{children:"Create a new taproot address:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:"ord --regtest --bitcoin-rpc-pass rpcpassword --bitcoin-rpc-user rpcuser wallet receive\n"})}),"\n",(0,r.jsx)(t.h4,{id:"7-prove-ownership-of-the-address",children:"7. Prove Ownership of the Address"}),"\n",(0,r.jsx)(t.p,{children:"Now finally, initiate the proving of an address:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:"cargo run --bin taproot-prover -- --address 0000000000000000000000000000000000000001 --taproot-address $TAPROOT_ADDRESS_FROM_PREVIOUS_STEP --bonsai-api-key=$API_KEY\n"})}),"\n",(0,r.jsxs)(t.p,{children:["The command above, if it runs successfully, will initiate the generation of a zk-proof on the Bonsai server, and after completion (which can take a couple of minutes), it will submit it to BOB Sepolia (Testnet) for verification. After waiting a couple of minutes, you will be able to see the result in the explorer. Go to ",(0,r.jsx)(t.a,{href:"https://explorerl2-fluffy-bob-7mjgi9pmtg.t.conduit.xyz/",children:"the explorer"})," and search for the previously logged ",(0,r.jsx)(t.code,{children:"$TAPROOT_REGISTER"}),' address. Go to the "Internal Transactions", click the latest transaction, and click "Logs". You should see an ',(0,r.jsx)(t.code,{children:"OwnershipProven"})," event, showing your Ethereum and taproot address."]}),"\n",(0,r.jsx)(t.h2,{id:"diving-into-the-code",children:"Diving into the Code"}),"\n",(0,r.jsxs)(t.p,{children:["The guest program running inside the zkVM can be found in ",(0,r.jsx)(t.a,{href:"https://github.com/bob-collective/demo-zkvm-taproot-address/blob/main/methods/guest/src/main.rs",children:"methods/guest/src/main.rs"})," and ",(0,r.jsx)(t.a,{href:"https://github.com/bob-collective/demo-zkvm-taproot-address/blob/main/methods/guest/src/lib.rs",children:"methods/guest/src/lib.rs"}),". This code takes the private key of the taproot address and a public EVM address (both encoded using the Ethereum ABI), and outputs the derived the bech32m address. The EVM address is passed through unprocessed. Note that in production you wouldn't want to do this, since you'd assume that the host is an untrusted component."]}),"\n",(0,r.jsxs)(t.p,{children:["The code for extracting the private key associated with an address can be found in ",(0,r.jsx)(t.a,{href:"https://github.com/bob-collective/demo-zkvm-taproot-address/blob/main/taproot-prover/src/main.rs",children:"taproot-prover/src/main.rs"}),". Note that this is not very straightforward, since with descriptor wallets the RPC commands for directly dumping private addresses do not work."]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>n,x:()=>a});var r=i(6540);const o={},s=r.createContext(o);function n(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:n(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);