"use strict";(self.webpackChunkBOB_docs=self.webpackChunkBOB_docs||[]).push([[3293],{9890:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>c,toc:()=>l});var s=i(4848),n=i(8453);const o={sidebar_position:3,sidebar_label:"Interact with Bitcoin from BOB Smart Contracts"},r="Bitcoin Light Client",c={id:"build/bob-sdk/relay",title:"Bitcoin Light Client",description:"We have chosen to use the production-ready tBTC-v2 (summa / keep-network) relay contracts and supporting libraries to support the initial development of the BOB stack. The contracts are already well-optimized for gas consumption and have been used on mainnet Ethereum for quite some time.",source:"@site/docs/build/bob-sdk/relay.md",sourceDirName:"build/bob-sdk",slug:"/build/bob-sdk/relay",permalink:"/docs/build/bob-sdk/relay",draft:!1,unlisted:!1,editUrl:"https://github.com/bob-collective/bob/tree/master/docs/docs/build/bob-sdk/relay.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,sidebar_label:"Interact with Bitcoin from BOB Smart Contracts"},sidebar:"buildSidebar",previous:{title:"BOB Bitcoin MetaMask Snap",permalink:"/docs/build/bob-sdk/metamask-snap"},next:{title:"sats-wagmi - Reactive primitives for Bitcoin apps",permalink:"/docs/build/bob-sdk/sats-wagmi"}},d={},l=[{value:"Features",id:"features",level:2},{value:"How Does it Work?",id:"how-does-it-work",level:2},{value:"Using The Relay",id:"using-the-relay",level:2},{value:"Adding BOB contracts as dependency",id:"adding-bob-contracts-as-dependency",level:3},{value:"Build the code",id:"build-the-code",level:3},{value:"Run the tests",id:"run-the-tests",level:3},{value:"Using the Contracts from TypeScript",id:"using-the-contracts-from-typescript",level:3},{value:"Validating Merkle Proofs (SPV)",id:"validating-merkle-proofs-spv",level:3},{value:"Validating Merkle Proofs (SPV + Witness)",id:"validating-merkle-proofs-spv--witness",level:3},{value:"Checking Output Amounts",id:"checking-output-amounts",level:3}];function a(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,n.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"bitcoin-light-client",children:"Bitcoin Light Client"})}),"\n",(0,s.jsxs)(t.p,{children:["We have chosen to use the production-ready ",(0,s.jsx)(t.a,{href:"https://github.com/keep-network/tbtc-v2/blob/main/solidity/contracts/relay/LightRelay.sol",children:(0,s.jsx)(t.strong,{children:"tBTC-v2"})})," (summa / keep-network) relay contracts and supporting libraries to support the initial development of the BOB stack. The contracts are already well-optimized for gas consumption and have been used on mainnet Ethereum for quite some time."]}),"\n",(0,s.jsx)(t.p,{children:'A specific advantage of using the Simple Payment Verification (SPV) "Light Relay" developed for tBTC is that we do not need to store all block headers from the genesis / initialization height. It uses stateless SPV proofs and provides some recency guarantee using Bitcoin\'s difficulty adjustment based on the latest retarget.'}),"\n",(0,s.jsx)(t.h2,{id:"features",children:"Features"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Proof that a Bitcoin transaction happened on Bitcoin to a smart contract on BOB"}),"\n",(0,s.jsx)(t.li,{children:"Verify Bitcoin block headers from smart contracts on BOB"}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"how-does-it-work",children:"How Does it Work?"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"The light relay is initialized to the beginning of a difficulty period (epoch)"}),"\n",(0,s.jsxs)(t.li,{children:['A "maintainer" submits ',(0,s.jsx)(t.code,{children:"proofLength"})," block headers before and after the retarget"]}),"\n",(0,s.jsx)(t.li,{children:"The relay validates the chain and updates the expected difficulty for blocks in that epoch"}),"\n",(0,s.jsxs)(t.li,{children:["A user can then submit a transaction proof in that or the last period","\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Requires header chain of at least ",(0,s.jsx)(t.code,{children:"txProofDifficultyFactor"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"using-the-relay",children:"Using The Relay"}),"\n",(0,s.jsxs)(t.p,{children:["The code for the light relay is in ",(0,s.jsx)(t.a,{href:"https://github.com/bob-collective/bob/blob/master/src/relay/LightRelay.sol",children:(0,s.jsx)(t.code,{children:"src/relay/LightRelay.sol"})})," which stores the difficulty for the current and previous epoch. To update this it is possible to use ",(0,s.jsx)(t.code,{children:"retarget(headers)"})," with ",(0,s.jsx)(t.code,{children:"proofLength * 2"})," block headers from Bitcoin (before and after the retarget) serialized sequentially."]}),"\n",(0,s.jsx)(t.h3,{id:"adding-bob-contracts-as-dependency",children:"Adding BOB contracts as dependency"}),"\n",(0,s.jsxs)(t.p,{children:["To add the BOB contracts to your own projects, if your project is using Foundry, you can simply run ",(0,s.jsx)(t.code,{children:"forge install bob-collective/bob"})," to add BOB contracts as a dependency to your project."]}),"\n",(0,s.jsx)(t.h3,{id:"build-the-code",children:"Build the code"}),"\n",(0,s.jsxs)(t.p,{children:["To build all the contracts, run ",(0,s.jsx)(t.code,{children:"forge build"}),"."]}),"\n",(0,s.jsx)(t.h3,{id:"run-the-tests",children:"Run the tests"}),"\n",(0,s.jsxs)(t.p,{children:["To run the built-in tests, run ",(0,s.jsx)(t.code,{children:"forge test"}),"."]}),"\n",(0,s.jsx)(t.h3,{id:"using-the-contracts-from-typescript",children:"Using the Contracts from TypeScript"}),"\n",(0,s.jsx)(t.admonition,{title:"BOB SDK",type:"tip",children:(0,s.jsxs)(t.p,{children:["To get the required input data for the contract, use the ",(0,s.jsx)(t.code,{children:"getBitcoinHeaders"})," function to automatically read ",(0,s.jsx)(t.code,{children:"numBlocks"})," from the configured Electrs REST API."]})}),"\n",(0,s.jsx)(t.h3,{id:"validating-merkle-proofs-spv",children:"Validating Merkle Proofs (SPV)"}),"\n",(0,s.jsxs)(t.p,{children:["To check the inclusion of a specific transaction, the ",(0,s.jsx)(t.code,{children:"BitcoinTx.validateProof"})," function can be used. See ",(0,s.jsx)(t.a,{href:"https://github.com/bob-collective/bob/blob/master/test/LightRelay.t.sol",children:(0,s.jsx)(t.code,{children:"test/LightRelay.t.sol"})})," for an example. This requires the serialized transaction and merkle proof with ",(0,s.jsx)(t.code,{children:"txProofDifficultyFactor"})," block headers to prove sufficient work has been built on top."]}),"\n",(0,s.jsx)(t.admonition,{title:"BOB SDK",type:"tip",children:(0,s.jsxs)(t.p,{children:["Refer to the ",(0,s.jsx)(t.code,{children:"getBitcoinTxProof"})," and ",(0,s.jsx)(t.code,{children:"getBitcoinTxInfo"})," functions to encode the expected arguments."]})}),"\n",(0,s.jsx)(t.h3,{id:"validating-merkle-proofs-spv--witness",children:"Validating Merkle Proofs (SPV + Witness)"}),"\n",(0,s.jsx)(t.admonition,{type:"info",children:(0,s.jsx)(t.p,{children:"Why might you want to do this? Under normal SPV assumptions it is not possible to prove witness data (such as Ordinal inscriptions) are included on the main chain."})}),"\n",(0,s.jsx)(t.p,{children:"To check that witness data is also included according to the relay we need to do the following:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"Verify coinbase is included (tx + merkle proof)"}),"\n",(0,s.jsx)(t.li,{children:"Verify payment is included (tx + merkle proof)"}),"\n",(0,s.jsx)(t.li,{children:"Validate witness commitment (extract root from coinbase, provide merkle proof for wtxids)"}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["Use the ",(0,s.jsx)(t.code,{children:"WitnessTx.validateWitnessProof"})," function to verify witness data is included. See ",(0,s.jsx)(t.a,{href:"https://github.com/bob-collective/bob/blob/master/test/WitnessTx.t.sol",children:(0,s.jsx)(t.code,{children:"test/WitnessTx.t.sol"})})," for an example. As above, this requires the serialized transaction and merkle proof for the ",(0,s.jsx)(t.strong,{children:"coinbase"})," transaction. To verify the witness data is included we need to encode the ",(0,s.jsx)(t.strong,{children:"payment"})," arguments differently. Check the expected structs in ",(0,s.jsx)(t.a,{href:"https://github.com/bob-collective/bob/blob/master/src/bridge/WitnessTx.sol",children:(0,s.jsx)(t.code,{children:"src/bridge/WitnessTx.sol"})}),", it requires a ",(0,s.jsx)(t.code,{children:"witnessVector"})," and separate witness merkle root hash built using the block's \"wtxids\" - transactions serialized with the witness data and then hashed according to Bitcoin's double sha2."]}),"\n",(0,s.jsx)(t.admonition,{title:"BOB SDK",type:"warning",children:(0,s.jsxs)(t.p,{children:["This approach is still experimental and not yet fully supported by the SDK. To construct the arguments as before use ",(0,s.jsx)(t.code,{children:"getBitcoinTxProof"})," but set ",(0,s.jsx)(t.code,{children:"forWitness"})," to ",(0,s.jsx)(t.code,{children:"true"})," for ",(0,s.jsx)(t.code,{children:"getBitcoinTxInfo"})," to get the ",(0,s.jsx)(t.code,{children:"witnessVector"}),". To construct the witness merkle proof follow the test in ",(0,s.jsx)(t.a,{href:"https://github.com/bob-collective/bob/blob/master/sdk/test/utils.test.ts",children:(0,s.jsx)(t.code,{children:"sdk/test/utils.test.ts"})})," using ",(0,s.jsx)(t.code,{children:"getMerkleProof"})," with the full raw block data."]})}),"\n",(0,s.jsx)(t.h3,{id:"checking-output-amounts",children:"Checking Output Amounts"}),"\n",(0,s.jsxs)(t.p,{children:["To extract the output amount ",(0,s.jsx)(t.code,{children:"BitcoinTx.processTxOutputs"})," can be used to extract the amount transferred to a specific address. See ",(0,s.jsx)(t.a,{href:"https://github.com/bob-collective/bob/blob/master/test/BitcoinTx.t.sol",children:(0,s.jsx)(t.code,{children:"test/BitcoinTx.t.sol"})})," for an example. The address is the ",(0,s.jsx)(t.code,{children:"keccak256"})," hash of the expected ",(0,s.jsx)(t.code,{children:"scriptPubKey"}),"."]}),"\n",(0,s.jsx)(t.admonition,{title:"BOB SDK",type:"tip",children:(0,s.jsxs)(t.p,{children:["Use ",(0,s.jsx)(t.code,{children:"getBitcoinTxInfo"})," and pass the ",(0,s.jsx)(t.code,{children:"outputVector"}),"."]})})]})}function h(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>r,x:()=>c});var s=i(6540);const n={},o=s.createContext(n);function r(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);