"use strict";(self.webpackChunkBOB_docs=self.webpackChunkBOB_docs||[]).push([[9238],{2856:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>h,default:()=>o,frontMatter:()=>s,metadata:()=>c,toc:()=>l});var r=n(4848),i=n(8453);const s={},h="LightRelay",c={id:"contracts/src/src/relay/LightRelay.sol/contract.LightRelay",title:"LightRelay",description:"Git Source",source:"@site/docs/contracts/src/src/relay/LightRelay.sol/contract.LightRelay.md",sourceDirName:"contracts/src/src/relay/LightRelay.sol",slug:"/contracts/src/src/relay/LightRelay.sol/contract.LightRelay",permalink:"/docs/contracts/src/src/relay/LightRelay.sol/contract.LightRelay",draft:!1,unlisted:!1,editUrl:"https://github.com/bob-collective/bob/tree/master/docs/docs/contracts/src/src/relay/LightRelay.sol/contract.LightRelay.md",tags:[],version:"current",frontMatter:{},sidebar:"contractSidebar",previous:{title:"IRelay",permalink:"/docs/contracts/src/src/relay/IRelay.sol/interface.IRelay"},next:{title:"ILightRelay",permalink:"/docs/contracts/src/src/relay/LightRelay.sol/interface.ILightRelay"}},d={},l=[{value:"State Variables",id:"state-variables",level:2},{value:"ready",id:"ready",level:3},{value:"authorizationRequired",id:"authorizationrequired",level:3},{value:"proofLength",id:"prooflength",level:3},{value:"genesisEpoch",id:"genesisepoch",level:3},{value:"currentEpoch",id:"currentepoch",level:3},{value:"currentEpochDifficulty",id:"currentepochdifficulty",level:3},{value:"prevEpochDifficulty",id:"prevepochdifficulty",level:3},{value:"epochs",id:"epochs",level:3},{value:"isAuthorized",id:"isauthorized",level:3},{value:"Functions",id:"functions",level:2},{value:"relayActive",id:"relayactive",level:3},{value:"genesis",id:"genesis",level:3},{value:"setProofLength",id:"setprooflength",level:3},{value:"setAuthorizationStatus",id:"setauthorizationstatus",level:3},{value:"authorize",id:"authorize",level:3},{value:"deauthorize",id:"deauthorize",level:3},{value:"retarget",id:"retarget",level:3},{value:"validateChain",id:"validatechain",level:3},{value:"getBlockDifficulty",id:"getblockdifficulty",level:3},{value:"getRelayRange",id:"getrelayrange",level:3},{value:"getCurrentEpochDifficulty",id:"getcurrentepochdifficulty",level:3},{value:"getPrevEpochDifficulty",id:"getprevepochdifficulty",level:3},{value:"getCurrentAndPrevEpochDifficulty",id:"getcurrentandprevepochdifficulty",level:3},{value:"getEpochDifficulty",id:"getepochdifficulty",level:3},{value:"validateHeader",id:"validateheader",level:3}];function a(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"lightrelay",children:"LightRelay"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.a,{href:"https://github.com/bob-collective/bob/blob/master/src/relay/LightRelay.sol",children:"Git Source"})}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Inherits:"}),"\nOwnable, ",(0,r.jsx)(t.a,{href:"/docs/contracts/src/src/relay/LightRelay.sol/interface.ILightRelay",children:"ILightRelay"})]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.em,{children:"The LightRelay contract manages a relay for Bitcoin header information,\nallowing retargeting and validation of header chains.\nTHE RELAY MUST NOT BE USED BEFORE GENESIS AND AT LEAST ONE RETARGET."})}),"\n",(0,r.jsx)(t.h2,{id:"state-variables",children:"State Variables"}),"\n",(0,r.jsx)(t.h3,{id:"ready",children:"ready"}),"\n",(0,r.jsx)(t.p,{children:"Flag indicating whether the relay is ready for use."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-solidity",children:"bool public ready;\n"})}),"\n",(0,r.jsx)(t.h3,{id:"authorizationrequired",children:"authorizationRequired"}),"\n",(0,r.jsx)(t.p,{children:"Flag indicating whether authorization is required for retarget submitters."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-solidity",children:"bool public authorizationRequired;\n"})}),"\n",(0,r.jsx)(t.h3,{id:"prooflength",children:"proofLength"}),"\n",(0,r.jsx)(t.p,{children:"Number of blocks required for each side of a retarget proof."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-solidity",children:"uint64 public proofLength;\n"})}),"\n",(0,r.jsx)(t.h3,{id:"genesisepoch",children:"genesisEpoch"}),"\n",(0,r.jsx)(t.p,{children:"The number of the first epoch recorded by the relay."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-solidity",children:"uint64 public genesisEpoch;\n"})}),"\n",(0,r.jsx)(t.h3,{id:"currentepoch",children:"currentEpoch"}),"\n",(0,r.jsx)(t.p,{children:"The number of the latest epoch whose difficulty is proven to the relay."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-solidity",children:"uint64 public currentEpoch;\n"})}),"\n",(0,r.jsx)(t.h3,{id:"currentepochdifficulty",children:"currentEpochDifficulty"}),"\n",(0,r.jsx)(t.p,{children:"Difficulty of the current epoch."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-solidity",children:"uint256 internal currentEpochDifficulty;\n"})}),"\n",(0,r.jsx)(t.h3,{id:"prevepochdifficulty",children:"prevEpochDifficulty"}),"\n",(0,r.jsx)(t.p,{children:"Difficulty of the previous epoch."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-solidity",children:"uint256 internal prevEpochDifficulty;\n"})}),"\n",(0,r.jsx)(t.h3,{id:"epochs",children:"epochs"}),"\n",(0,r.jsx)(t.p,{children:"Mapping of each epoch from genesis to the current one, keyed by their numbers."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-solidity",children:"mapping(uint256 => Epoch) internal epochs;\n"})}),"\n",(0,r.jsx)(t.h3,{id:"isauthorized",children:"isAuthorized"}),"\n",(0,r.jsx)(t.p,{children:"Mapping of authorized submitters."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-solidity",children:"mapping(address => bool) public isAuthorized;\n"})}),"\n",(0,r.jsx)(t.h2,{id:"functions",children:"Functions"}),"\n",(0,r.jsx)(t.h3,{id:"relayactive",children:"relayActive"}),"\n",(0,r.jsx)(t.p,{children:"Modifier to check if the relay is active."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-solidity",children:"modifier relayActive();\n"})}),"\n",(0,r.jsx)(t.h3,{id:"genesis",children:"genesis"}),"\n",(0,r.jsx)(t.p,{children:"Establish a starting point for the relay by providing the\ntarget, timestamp and blockheight of the first block of the relay\ngenesis epoch."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.em,{children:"If the relay is used by querying the current and previous epoch\ndifficulty, at least one retarget needs to be provided after genesis;\notherwise the prevEpochDifficulty will be uninitialised and zero."})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-solidity",children:"function genesis(bytes calldata genesisHeader, uint256 genesisHeight, uint64 genesisProofLength) external onlyOwner;\n"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"genesisHeader"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"bytes"})}),(0,r.jsx)(t.td,{children:"The first block header of the genesis epoch."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"genesisHeight"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"uint256"})}),(0,r.jsx)(t.td,{children:"The block number of the first block of the epoch."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"genesisProofLength"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"uint64"})}),(0,r.jsx)(t.td,{children:"The number of blocks required to accept a proof."})]})]})]}),"\n",(0,r.jsx)(t.h3,{id:"setprooflength",children:"setProofLength"}),"\n",(0,r.jsx)(t.p,{children:"Set the number of blocks required to accept a header chain."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.em,{children:"For production, a high number (e.g. 20-50) is recommended.\nSmall numbers are accepted but should only be used for testing."})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-solidity",children:"function setProofLength(uint64 newLength) external relayActive onlyOwner;\n"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsx)(t.tbody,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"newLength"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"uint64"})}),(0,r.jsx)(t.td,{children:"The required number of blocks. Must be less than 2016."})]})})]}),"\n",(0,r.jsx)(t.h3,{id:"setauthorizationstatus",children:"setAuthorizationStatus"}),"\n",(0,r.jsx)(t.p,{children:"Set whether the relay requires retarget submitters to be\npre-authorised by governance."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-solidity",children:"function setAuthorizationStatus(bool status) external onlyOwner;\n"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsx)(t.tbody,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"status"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"bool"})}),(0,r.jsx)(t.td,{children:"True if authorisation is to be required, false if not."})]})})]}),"\n",(0,r.jsx)(t.h3,{id:"authorize",children:"authorize"}),"\n",(0,r.jsx)(t.p,{children:"Authorise the given address to submit retarget proofs."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-solidity",children:"function authorize(address submitter) external onlyOwner;\n"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsx)(t.tbody,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"submitter"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"address"})}),(0,r.jsx)(t.td,{children:"The address to be authorised."})]})})]}),"\n",(0,r.jsx)(t.h3,{id:"deauthorize",children:"deauthorize"}),"\n",(0,r.jsx)(t.p,{children:"Rescind the authorisation of the submitter to retarget."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-solidity",children:"function deauthorize(address submitter) external onlyOwner;\n"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsx)(t.tbody,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"submitter"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"address"})}),(0,r.jsx)(t.td,{children:"The address to be deauthorised."})]})})]}),"\n",(0,r.jsx)(t.h3,{id:"retarget",children:"retarget"}),"\n",(0,r.jsx)(t.p,{children:"Add a new epoch to the relay by providing a proof\nof the difficulty before and after the retarget."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.em,{children:"Checks that the first X blocks are valid in the most recent epoch,\nthat the difficulty of the new epoch is calculated correctly according\nto the block timestamps, and that the next X blocks would be valid in\nthe new epoch.\nWe have no information of block heights, so we cannot enforce that\nretargets only happen every 2016 blocks; instead, we assume that this\nis the case if a valid proof of work is provided.\nIt is possible to cheat the relay by providing X blocks from earlier in\nthe most recent epoch, and then mining X new blocks after them.\nHowever, each of these malicious blocks would have to be mined to a\nhigher difficulty than the legitimate ones.\nAlternatively, if the retarget has not been performed yet, one could\nfirst mine X blocks in the old difficulty with timestamps set far in\nthe future, and then another X blocks at a greatly reduced difficulty.\nIn either case, cheating the relay requires more work than mining X\nlegitimate blocks.\nOnly the most recent epoch is vulnerable to these attacks; once a\nretarget has been proven to the relay, the epoch is immutable even if a\ncontradictory proof were to be presented later."})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-solidity",children:"function retarget(bytes memory headers) external relayActive;\n"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsx)(t.tbody,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"headers"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"bytes"})}),(0,r.jsx)(t.td,{children:"A chain of headers including the last X blocks before the retarget, followed by the first X blocks after the retarget, where X equals the current proof length."})]})})]}),"\n",(0,r.jsx)(t.h3,{id:"validatechain",children:"validateChain"}),"\n",(0,r.jsx)(t.p,{children:"Check whether a given chain of headers should be accepted as\nvalid within the rules of the relay.\nIf the validation fails, this function throws an exception."}),"\n",(0,r.jsx)(t.p,{children:"*A chain of headers is accepted as valid if:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Its length is between 2 and 2015 headers."}),"\n",(0,r.jsx)(t.li,{children:"Headers in the chain are sequential and refer to previous digests."}),"\n",(0,r.jsx)(t.li,{children:"Each header is mined with the correct amount of work."}),"\n",(0,r.jsx)(t.li,{children:"The difficulty in each header matches an epoch of the relay,\nas determined by the headers' timestamps. The headers must be between\nthe genesis epoch and the latest proven epoch (inclusive).\nIf the chain contains a retarget, it is accepted if the retarget has\nalready been proven to the relay.\nIf the chain contains blocks of an epoch that has not been proven to\nthe relay (after a retarget within the header chain, or when the entire\nchain falls within an epoch that has not been proven yet), it will be\nrejected.\nOne exception to this is when two subsequent epochs have exactly the\nsame difficulty; headers from the latter epoch will be accepted if the\nprevious epoch has been proven to the relay.\nThis is because it is not possible to distinguish such headers from\nheaders of the previous epoch.\nIf the difficulty increases significantly between relay genesis and the\npresent, creating fraudulent proofs for earlier epochs becomes easier.\nUsers of the relay should check the timestamps of valid headers and\nonly accept appropriately recent ones.*"}),"\n"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-solidity",children:"function validateChain(bytes memory headers)\n    external\n    view\n    returns (uint256 startingHeaderTimestamp, uint256 headerCount);\n"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsx)(t.tbody,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"headers"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"bytes"})}),(0,r.jsx)(t.td,{children:"A chain of 2 to 2015 bitcoin headers."})]})})]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Returns"})}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"startingHeaderTimestamp"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"uint256"})}),(0,r.jsx)(t.td,{children:"The timestamp of the first header."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"headerCount"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"uint256"})}),(0,r.jsx)(t.td,{children:"The number of headers."})]})]})]}),"\n",(0,r.jsx)(t.h3,{id:"getblockdifficulty",children:"getBlockDifficulty"}),"\n",(0,r.jsx)(t.p,{children:"Get the difficulty of the specified block."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-solidity",children:"function getBlockDifficulty(uint256 blockNumber) external view returns (uint256);\n"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsx)(t.tbody,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"blockNumber"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"uint256"})}),(0,r.jsx)(t.td,{children:"The number of the block. Must fall within the relay range (at or after the relay genesis, and at or before the end of the most recent epoch proven to the relay)."})]})})]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Returns"})}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsx)(t.tbody,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"<none>"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"uint256"})}),(0,r.jsx)(t.td,{children:"The difficulty of the epoch."})]})})]}),"\n",(0,r.jsx)(t.h3,{id:"getrelayrange",children:"getRelayRange"}),"\n",(0,r.jsx)(t.p,{children:"Get the range of blocks the relay can accept proofs for."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.em,{children:"Assumes that the genesis has been set correctly.\nAdditionally, if the next epoch after the current one has the exact\nsame difficulty, headers for it can be validated as well.\nThis function should be used for informative purposes,\ne.g. to determine whether a retarget must be provided before submitting\na header chain for validation."})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-solidity",children:"function getRelayRange() external view returns (uint256 relayGenesis, uint256 currentEpochEnd);\n"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Returns"})}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"relayGenesis"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"uint256"})}),(0,r.jsx)(t.td,{children:"The height of the earliest block that can be included in header chains for the relay to validate."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"currentEpochEnd"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"uint256"})}),(0,r.jsx)(t.td,{children:"The height of the last block that can be included in header chains for the relay to validate."})]})]})]}),"\n",(0,r.jsx)(t.h3,{id:"getcurrentepochdifficulty",children:"getCurrentEpochDifficulty"}),"\n",(0,r.jsx)(t.p,{children:"Returns the difficulty of the current epoch."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.em,{children:"returns 0 if the relay is not ready."})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-solidity",children:"function getCurrentEpochDifficulty() external view virtual returns (uint256);\n"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Returns"})}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsx)(t.tbody,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"<none>"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"uint256"})}),(0,r.jsx)(t.td,{children:"The difficulty of the current epoch."})]})})]}),"\n",(0,r.jsx)(t.h3,{id:"getprevepochdifficulty",children:"getPrevEpochDifficulty"}),"\n",(0,r.jsx)(t.p,{children:"Returns the difficulty of the previous epoch."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.em,{children:"Returns 0 if the relay is not ready or has not had a retarget."})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-solidity",children:"function getPrevEpochDifficulty() external view virtual returns (uint256);\n"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Returns"})}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsx)(t.tbody,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"<none>"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"uint256"})}),(0,r.jsx)(t.td,{children:"The difficulty of the previous epoch."})]})})]}),"\n",(0,r.jsx)(t.h3,{id:"getcurrentandprevepochdifficulty",children:"getCurrentAndPrevEpochDifficulty"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-solidity",children:"function getCurrentAndPrevEpochDifficulty() external view returns (uint256 current, uint256 previous);\n"})}),"\n",(0,r.jsx)(t.h3,{id:"getepochdifficulty",children:"getEpochDifficulty"}),"\n",(0,r.jsx)(t.p,{children:"Get the difficulty of the specified epoch."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-solidity",children:"function getEpochDifficulty(uint256 epochNumber) public view returns (uint256);\n"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsx)(t.tbody,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"epochNumber"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"uint256"})}),(0,r.jsx)(t.td,{children:"The number of the epoch (the height of the first block of the epoch, divided by 2016). Must fall within the relay range."})]})})]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Returns"})}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsx)(t.tbody,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"<none>"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"uint256"})}),(0,r.jsx)(t.td,{children:"The difficulty of the epoch."})]})})]}),"\n",(0,r.jsx)(t.h3,{id:"validateheader",children:"validateHeader"}),"\n",(0,r.jsx)(t.p,{children:"Check that the specified header forms a correct chain with the\ndigest of the previous header (if provided), and has sufficient work."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.em,{children:"Throws an exception if the header's chain or PoW are invalid.\nPerforms no other validation."})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-solidity",children:"function validateHeader(bytes memory headers, uint256 start, bytes32 prevDigest)\n    internal\n    view\n    returns (bytes32 digest, uint256 target);\n"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"headers"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"bytes"})}),(0,r.jsx)(t.td,{children:"The byte array containing the header of interest."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"start"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"uint256"})}),(0,r.jsx)(t.td,{children:"The start of the header in the array."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"prevDigest"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"bytes32"})}),(0,r.jsx)(t.td,{children:"The digest of the previous header (optional; providing zeros for the digest skips the check)."})]})]})]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Returns"})}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"digest"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"bytes32"})}),(0,r.jsx)(t.td,{children:"The digest of the current header."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"target"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"uint256"})}),(0,r.jsx)(t.td,{children:"The PoW target of the header."})]})]})]})]})}function o(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>h,x:()=>c});var r=n(6540);const i={},s=r.createContext(i);function h(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:h(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);